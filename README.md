Crius: A package for calculating the elastic moduli of 2D and 3D multiphase materials
=====================================================================================

Crius is a Python package to compute the elastic response of multiphase materials.The Gmsh software is used to generate the domain and mesh and the dolfin library from the FEniCs project is used to numerically solve the elastic problem. The high-level objective of this research project is to investigate the relation between the microstructure and the effective elastic properties of multiphase materials through a static finite element code and analyse relations that link porosity with the elastic moduli of multiphase materials. 

Crius package is divided into three directories: pre-processing, numerical-analysis and post-processing.

Crius was developed as an individual project for the MSc Applied Computational Science and Engineering offered by Imperial College London.

## Installation

### Installation of Crius

1. `git clone https://github.com/acse-2019/irp-acseai1419.git`
2. `cd Code/Crius`

Crius was built in a Linux environment as a standalony Python package using the dolfin library from FEniCS project.
It is recommended that FEniCS project is installed using the Conda package manager for the software dependancies using 3.8 version.

### Installation of FEniCS project and Mshr Library

3. `conda create -n fenicsproject -c conda-forge fenics`
4. `source activate fenicsproject`
5. `conda install -c conda-forge mshr`

### Installation of Gmsh software (version 4.6.0 was used)

6. `sudo apt-get update -y`
7. `sudo apt-get install -y gmsh`

### Installation of ParaView (version 5.7.0 was used)

8. `sudo apt-get install -y paraview`

## Architecture

### pre-processing

- mesh_mpi: Takes a mesh of xml format generated by Gmsh and converted with dolphin and converts into HDF5, so it can be read in parallel

#### 2-D

The modules in pre-processing/2-D by default are executed from the base. They also generate text files for using the semi-automatic solution with gmsh instead of the mshr library. 

- create_circular_incl : Returns information of randomly distributed cirlular inclusions inside or partly inside a square.
- create_layers: Returns information for a composite 2-D laminate material.
- create_mesh: generates the 2D mesh and subdomains with the Mshr library.

#### 3-D

The scripts in pre-processing/3-D are executed as standalone scripts as they generate files for the semi-automatic solution for creating 3D meshes with Gmsh software.

- create_spherical_incl: Writes information of randomly distributed spherical inclusions inside a box.
- create_ellipsoidal_incl: Writes information of ellipsoids with location specified by the user.
- create_3D_Layers: Writes information of a composite 3-D laminate material.
- create_CT_Scan: Writes information of a 3-D CT Scan where each voxel of the image represents a geometric element.

### 3-D CT SCAN

This directory is under development in order to take a stack of 2-D CT-scan images and convert them into a 3D volumetric mesh to be imported for the numerical analysis

### meshes

#### txt_mesh

- Contains the geometric information generated from the pre-processing modules which need to be transfered in the geo files to generate the mesh with Gmsh software.
- Contains the geometric information from mshr.

#### gmsh

- Contains all the geo files that are needed to generate the mesh with Gmsh.
- Contains a jupyter notebook which explains how the semi-automatic solution works and the steps to be followed.
- contains the xml files after the meshes are generated.

#### mpi_mesh

- Contains the HDF5 file to be read when running the code in parallel.

### Numerical Analysis

- epilysis_functions: Contains the lower level functions required for the numerical analysis in 2-D.
- epilysis: Contains the numerical analysis functions in 2-D.
- epilysis_functions_3D: Contains the lower level functions required for the numerical analysis in 3-D.
- epilysis_3D: Contains the numerical analysis functions in 3-D.
- i_o: Contains functions regarding inputs and outputs in 2-D.
- store: Contains functions regarding inputs and outputs in 3-D.

### Results

Contains data from the numerical analysis to be used by the Post-Processing directory.

### Paraview

Contains the vtk files in 2-D and 3-D obtained from the numerical analysis.

### Post Processing

- post: Contains functions for presenting the effective elastic moduli and functions to validate it against analytical solutions in 2-D.
- post3D: Contains functions for presenting the effective elastic moduli and functions to validate it against analytical solutions in 3-D.

### Analytical

Contains functions for the Voigt Reuss bounds,  the Mori-Tanaka solution and the Tendon-Wang solution (makes use of an external library fiberpy), to install it: `pip install fiberpy`

### Tutorials

Contains jupyter notebooks and python scripts with examples for using the Crius library.

## Tutorials

Tutorials make use of jupyter notebooks to demonstrate some examples for using the Crius library

To run the notebooks, jupyter needs to be installed after the fenicsproject environment is activated:

1. `conda activate fenicsproject`
2. `pip install notebook`
3. `jupyter notebook`
4. Find the tutorials in the tutorials directory

## Gmsh

For Gmsh a jupyter notebook is located in meshes/gmsh containing the steps to be followed to run the semi-automatic solution in 2-D and 3-D

Files generated with geometric and physical information in meshes/txt_mesh

Here is an example of the geometircal and physical information of spherical inclusions inside a homogeneous matrix

```C++
Sphere(2) = {x+0.3549102609084382, y+0.4378583379896717, z+0.6774137001468787, 0.2729716849727446}; 
Sphere(3) = {x+0.6873389809730316, y+0.7235779338235815, z+0.5119612836568483, 0.2549945139986808}; 
Sphere(4) = {x+0.6780590039110005, y+0.29971830545163425, z+0.3222318047364401, 0.25189830672522795}; 
Sphere(5) = {x+0.2144266917278429, y+0.5745433210648649, z+0.23748806384333598, 0.20669214036049305}; 
Sphere(6) = {x+0.7646316740823721, y+0.2227572565595214, z+0.7375795013893071, 0.20628966656176181}; 
v() = BooleanFragments { Volume{1}; Delete; }{ Volume{2 :6}; Delete; }; 
Physical Volume(1) = {7}; 
Physical Volume(2) = {2, 3, 4, 5, 6}; 
Mesh.CharacteristicLengthMin = 0.07; 
Mesh.CharacteristicLengthMax = 0.07; 
```

In gereral for generating the mesh from a .geo file in 3-D and convert it to the .xml files:

1. `gmsh -3 filename.geo -format msh2`
2. `dolfin-convert -i gmsh filename.msh filename.xml`

If the geo files are written correctly this will produce two .xml files containing the mesh and physical information about the subdomains.

## MPI

Before running the code on the HPC in parallel one will first need to install fenics project. It is strongly recomended to install it using Conda and make sure all dependancies are installed. To install fenics:

1. `module load anaconda3/personal`
2. `anaconda-setup`
3. `conda create -n fenicsproject -c conda-forge fenics`
4. `source activate fenicsproject`
5. Transfer the package in home directory
6. Navigate to the directory with the MPI script (here it is on the base)
7. Create a job by writing the following information in a text file called `filename.pbs` (In this example 48 cores are used):

```PBS
#PBS -N Mpi
#PBS -l walltime=02:00:00
#PBS -l select=1:ncpus=48:mpiprocs=48:mem=50GB

cd ~/Crius/
module load anaconda3/personal
source activate fenicsproject

mpirun -n 48 python  main_mpi.py
```
8. Execute the job by running `qsub filename.pbs`

